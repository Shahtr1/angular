So angular compiler generates the code that angular runtime can understand

When an application bootstraps there are 3 main steps it goes through
1.	Module setup
	Its related to module bootstap

The below two are related to component bootstrap

2.	View creation

3.	Change detection

We will talk about Component bootstrap

===================================================================================

code would be like this

```js
@NgModule({
	imports: [
		BrowserModule,
		MatcardModule
	],
	providers: [
		{provide: Info, useClass: HermesInfo}
	],
	declarations:[
		AppComponent, InfoCard, Footer
	],
	bootstrap: [AppComponent]
})
export class AppModule {}
```

```js
@Component({
	selector: 'app-root'
	template:`
		<img src="cat.jpg">
		<h1> {{ header }} </h1>
		<info-card [name]="name"></info-card>
		<footer></footer>
	`
})
class AppComponent {...}
```

================================================================


There are few steps that are done to set up the root component

1.	Locate root element
in index.html, there is like app-root
it should match whatever selector you have in root component
```js
@Component({
	selector: 'app-root'
	template:`
		<img src="cat.jpg">
		<h1> {{ header }} </h1>
		<info-card [name]="name"></info-card>
		<footer></footer>
	`
})
class AppComponent {...}
````

so when we compile this component, the selector gets compiled into the definition
```js
AppComponent.ngComponentDef = 
	defineComponent({
		selectors: [['app-root']],
		factory: function(){
			return new AppComponent();
		},
		template: function(flags,context){
			...
		},
		directives: [...],
		...
	});
```
framework just picks the selctor from component definition, and document.queryselector and so on.


2.	Instantiate root component
next we create the instance,
compiler generate a factory function for it, so we call that


3.	Render the root component
	
	-	View Creation
		Process where DOM is created and directives are instantiated.
		template function is used here,

		```js
		function(renderFlags, ctx){
			if(renderFlags & RenderFlags.Create){
				...
			}
			if(renderFlags & RenderFlags.Update){
				...
			}
		}
		```

		so in creation mode, we can invoke the template function
		```js
		App.ngComponentDef.template(create, app);
		InfoCard.ngComponentDef.template(create, info);
		Footer.ngComponentDef.template(create, footer);
		````

	What is a template functon?
	Its a function that is composed of a number of instructions	, its a function implemented by angular framework.
	There is creation instructions and update instructions.

	-	Creation Instructions
		element()
		text()
		template()
		elementContainer()
		projection()		// creates ng-content
		listener()
		pipe()
		i18n()
		...

	-	Update Instructions
		property()
		attribute()
		styleProp()
		classProp()
		hostProperty()
		pipeBind()
		textInterpolate1-8()
		pureFunction1-8()
		...

	so if we go in template,
	```js
	template:`
		<img src="cat.jpg">
		<h1> {{ header }} </h1>
		<info-card [name]="name"></info-card>
		<footer></footer>
	`
	````
	The compiler will generate something like this
	```js
	function(renderFlags, ctx){
		if(renderFlags && RenderFlags.Create){
			element(0, 'img', ['src', 'cat.jpg']);
			elementStart(1, 'h1');
				text(2);
			elementEnd();
			element(3, 'info-card');
			element(4, 'footer');
		}
		if(renderFlags & RenderFlags.Update){
			advance(2);
			textInterpolate('', ctx.header, '');
			advance(1);
			property('name', ctx.name);
		}
	}
	````
	lets explain creation mode, first
	The structure of template function is mirroring the structure of html template
	if we take a closer look at element function:
	```js
	function element(index, tag, attrs){
		const el = document.createElement(tag);
		const parent = getCurrentElement();
		setAttributes(el, attrs);
		parent.appendChild(el);
		lView[index] = el;
	}
	````
	we also track all the elements as we create them, we store them ina  data array.
	The reason is, because in change detection we would update them, so to access them.
	we use lView array.

	LView is also known as logical view.
	Data unique to particular view instance

	for creation mode, we are going through and we are adding each element as we create it

	```js
	[<img>, <h1>, #txt, <info-card>, <footer>, ...		]

	````

	There is one more thing that these element instructions are doing and that is directive matching.
	so at compile time the compiler will analyse the ngModules and Component decorator, and based on that
	it will tell teh component what directives are available in its module scope,
	 once it knows all the directives, it will print out all the directives inside the component definition.
	 ```js
	AppComponent.ngComponentDef = 
		defineComponent({
			selectors: [['app-root']],
			factory: function(){
				...
			},
			template: function(flags,context){
				...
			},
			directives: [ InfoCard, Footer ],
			...
		});
	````

	its easier now, 
	because the runtime dont have to worry about the module scope, because we know whats the list from definition.
	so as we are creating all these elements we are also matching directives against the elements that we are creating

	what we do is we call the components factory, same that we invoked in the beginning

	```js
	InfoCard.ngComponentDef = 
		defineComponent({
			...
			factory: function(){
				return new InfoCard(
					directiveInject(Info)
				);
			},
			template: function(flags,context){
				...
			},
			...
		});
	````

	so it just calls new method, but it also has 
	```js 
	directiveInject(Info)
	```
	its an instruction that powers DI for directives

	so directiveInject will take the token and it will first check the directive inject tree, the tree has all the directives that we provided on definitions as well as the directives in component themselves.
	and if its not there then it goes to Module Injector.
	Module Injector is where we keep track of providers that we set on NgModules.
	and if its not there, then it will return null or something.

	lets say we provide InfoService in app module
	```js
	@NgModule({
		imports: [
			BrowserModule,
			MatcardModule
		],
		providers: [
			{provide: Info, useClass: HermesInfo}
		],
		declarations:[
			AppComponent, InfoCard, Footer
		],
		bootstrap: [AppComponent]
	})
	export class AppModule {}
	```

	```js
	<app-root>
		<img src="cat.jpg">
		<h1>
			{{ header }}
		</h1>
		<info-card [name]="name"></info-card>
		<footer></footer>
	</app-root>
	````

	and when we creating info-card, we call directiveInject, 
	directoveInkect will check the node that we currently on
	i.e., Info card node
	it will say like this
	
	is there a directive injector here? NO
	is there a directive thats registering infoService as a provider? NO

	So it will move up to next parent element i.e., app-root
	so does the app-root provide info-service? NO

	so now we go to Module Injector

	and it sees there, that its provided there

	soon as we create the info card instance
	we will save it in same LView array

	This directive matching can be too expensive, there can be more than two directives
	so we dotn wanna do directive matching more than once for the component

	we wanna do first time we see that componenet and not after that

	we will do that by Shared data structures

	LView is a data unique to a particular view instance
	(1 per component instance)

	TView:
		Shared data between all instances of a view
		(1 per component type)

	e.g., if we have a component that has 10 instances
	it will have 10 LViews which will share 1 TView
	we store the TView in the component def

	Caching
	LView:
	```js
	[ <img>, <h1>, #txt, <info-card>, ..., infoCard, footer ]


	TView.data:
	[ TNode, TNode, TNode, TNode, ..., InfoCard.def, Footer.def ]
	````

	as we are pushing directive instances into the LView we are also pushign their definitions into the TView at the same index.
	similary as we are creating DOM elements we are also pushing template nodes into TView
	Template Nodes are the meta data of DOM elements, that will create info like tag name, and more impprtantly the info of directive matching
	On the TNode we will have the list of directive indices that match this node.
	For info-card, the second time we go into this app-component template, we go to this info card element we will check to see if there is a TNode of that instance that we already created
	The TNode will hold info about where the directives are stored for this node, and will point to def, (InfoCard.def) and then we instantiate this imeediately without doing any matching

	











		






